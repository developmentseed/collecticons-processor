const fs = require('fs-extra');
const get = require('lodash.get');
const zipObject = require('lodash.zipobject');
const SVGIcons2SVGFontStream = require('svgicons2svgfont');
const svg2ttf = require('svg2ttf');
const ttf2woff = require('ttf2woff');
const ttf2woff2 = require('ttf2woff2');

const generators = {
  svg: {
    fn: async function (options) {
      const svgOptions = {
        fontName: options.fontName,
        fontHeight: 1024,

        log: function () {}
      };

      return new Promise((resolve, reject) => {
        let font = Buffer.alloc(0);
        const fontStream = new SVGIcons2SVGFontStream(svgOptions)
          .on('data', data => {
            font = Buffer.concat([font, data]);
          })
          .on('end', () => resolve(font))
          .on('error', reject);

        options.icons.forEach(({ file, name, codepoint }) => {
          const unicode = String.fromCharCode(codepoint);
          let glyph = fs.createReadStream(file);

          let ligature = '';
          for (var i = 0; i < name.length; i++) {
            ligature += String.fromCharCode(name.charCodeAt(i));
          }

          glyph.metadata = {
            name,
            unicode: [unicode, ligature]
          };

          fontStream.write(glyph);
        });

        fontStream.end();
      });
    }
  },

  ttf: {
    deps: ['svg'],
    fn: async function (options, [svgFont]) {
      const opts = {
        copyright: 'Development Seed',
        description: 'Generated by Collecticons Processor',
        url: 'http://collecticons.io/',
        ts: process.env.NODE_ENV === 'test' ? 0 : undefined,
        ...get(options, 'formatOptions.ttf')
      };
      const font = svg2ttf(svgFont.toString(), opts);
      return Buffer.from(font.buffer);
    }
  },

  woff: {
    deps: ['ttf'],
    fn: async function (options, [ttfFont]) {
      const opts = get(options, 'formatOptions.woff');
      const font = ttf2woff(new Uint8Array(ttfFont), opts);
      return Buffer.from(font.buffer);
    }
  },

  woff2: {
    deps: ['ttf'],
    fn: async function (options, [ttfFont]) {
      const opts = get(options, 'formatOptions.woff2');
      const font = ttf2woff2(new Uint8Array(ttfFont), opts);
      return Buffer.from(font.buffer);
    }
  }
};

/**
 * Generated the svg, ttf, woff, and woff2 fonts.
 *
 * @param {object} options Configuration
 * @param {string} options.fontName Name of the font.
 * @param {array} options.icons List of icons. Each should have a `name` and
 *                `codepoint` properties.boolean
 * @param {object} options.formatOptions Configuration for each of the font
 *                 generation plugins
 *
 * @returns {object} Object keyed with the font type and respective content.
 *                   All fonts are returned in Buffer format.
 */
async function generateFonts (options = {}) {
  if (!options.fontName) throw new TypeError('Missing fontName argument');
  if (!options.icons || !Array.isArray(options.icons) || !options.icons.length) { throw new TypeError('Invalid or empty icons argument'); }
  // Store created tasks to match dependencies.
  let genTasks = {};

  /**
   * First, creates tasks for dependent font types.
   * Then creates task for specified font type and chains it to dependencies promises.
   * If some task already exists, it reuses it.
   */
  const makeGenTask = type => {
    // If already defined return.
    if (genTasks[type]) return genTasks[type];

    // Get generator function.
    const gen = generators[type];
    // Create dependent functions
    const depsTasks = (gen.deps || []).map(depType => makeGenTask(depType));
    const task = Promise.all(depsTasks).then(results =>
      gen.fn(options, results)
    );

    genTasks[type] = task;
    return task;
  };

  // Make a gen task for each type.
  const types = ['svg', 'ttf', 'woff', 'woff2'];
  const tasks = types.map(type => {
    return makeGenTask(type);
  });

  const results = await Promise.all(tasks);
  return zipObject(types, results);
}

module.exports = generateFonts;
